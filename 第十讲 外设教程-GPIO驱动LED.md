这节课开始，我们正式编写应用程序。ESP32由于具有一般MCU的外设功能，因此不仅仅可以使用它来进行WIFI数据传输，还可以将其作为主控单元，实现其他的控制逻辑。现在我们从最简单的GPIO（通用输入输出）操作开始。玩过STM32或者51的朋友肯定清楚GPIO是什么。没学过的也不要紧，其实GPIO称为通用输入输出，我们可以对某个引脚进行高低电平的操作，也可以让这个引脚检测外部输入的电平是什么，或者进行驱动一些简单的LED等功能。
对于ESP32来说，因为其供电系统要求的是典型电压值3.3伏，因此3.3伏是高电平，零伏是低电平。我们先来看这个简单的原理图，这个原理图中，ESP32的GPIO27引脚串联了一个电阻以及一个LED到地。如果我们想要点亮这个LED很简单，我们只需要操作这个引脚输出高电平，根据欧姆定律，线路上就会有电流流过LED，LED就可以亮起来。

现在回到我们的程序里面，我们写一个简单的程序，就是控制这个LED进行闪烁。我们打开VS Code，我们直接新建一个工程吧。工程名叫LED_Blink，新建完毕。直接编译一下。而VS Code这边也是打开我们刚才新建的这个工程，好，我们先等它编译完吧。第一次编译时间大概一分钟左右。好，编译完了，我们开始写我们的程序。我们是想新建一个任务，然后在任务里面延时500ms，就让GPIO电平翻转一次。那么我们包含一些必要的头文件，如果我们想要操作GPIO的话，我们就需要加入这个头文件。
好，现在我们新建一个任务，就叫LED_Run_Test，这个任务非常简单，就是每隔500ms，然后……我们先定义一下我们的GPIO引脚吧，开发板上的GPIO27是我们要使用的。那么这边我们就可以这么写。我们通过一个临时变量来控制这个翻转电平，这个临时变量用于翻转电平，逻辑如下：它首先判断当前电平是零还是一，如果当前电平是一的话，那么就重新给它赋一个零值，如果是零的话，重新给它赋一个一值，然后将这个电平通过GPIO_set_level这个API接口写入到我们的引脚上面去。
好，现在我们在app_main里面初始化一下这个GPIO引脚。那么如何初始化呢？其实ESP-IDF中，我们经常会看到这样一种代码，这种代码是首先要定义一个结构体，然后我们往结构体里面填充参数，填充之后成为一个配置，然后再将这个配置通过一个API函数设置到底层里面去。以后大家大部分看到这些流程的话，都是这样的模式。

那么关于GPIO的配置的话，是这么写。好，我们要首先定义一个GPIO配置结构体，然后对它赋值。先看，它是一个位掩码，按位掩码的意思就是它可以同时支持多个GPIO引脚一起进行设置。那么我们再看一下还有哪些成员，这个是是否启用上拉，因为我们是输出引脚，我们就不启用上拉GPIO，这个也是不启用下拉。然后模式的话，GPIO一般来说就是输入和输出模式，输入的话就是检测外部电平，输出的话就是输出高电平或者低电平，因为我们这边是要驱动LED，所以说我们是输出模式。还有中断，我们不需要中断，直接禁用。
好，那么调用这个GPIO_configure接口，把这个结构体设置进去，那么我们初始化就完成了。那么我们再新建一个任务，当然你在这个app_main函数里面直接闪烁也是可以的，这里都没有关系。好，我们程序就写完了，我们重新编译一下，编译没有问题，好，我们把程序烧进去，我们看下开发板吧。大家看到开发板上这个LED大概是500ms就闪一次，这也是和我们预期是一样的。

现在回到我们的课程。因为我们这个闪烁的话还是比较简单的，那么我们先来看一下一个稍微复杂一点的例子。根据我们的原理图分析，GPIO好像只能控制亮或者灭，有没有办法可以做到调节亮度呢？如果我们简单地操控电平高低，那肯定是做不到的。那如果我们输出的是一段带脉冲的波形，那又会怎样呢？脉冲包含高低电平，高电平的时候LED就亮，低电平的时候LED就灭，理论上我们看到的是一闪一闪的。那么当这段脉冲的周期非常短的时候，这种闪烁我们人眼是察觉不出来的，我们看到的就是灯会变暗一点。如果脉冲周期里低电平占比比较多，灯就会越暗，反之就越亮。因此，我们控制这段脉冲里的高低电平时间，就可以达到我们调节亮度的需求。换句专业话说，就是通过调节占空比来调节亮度。
那么在大多数的MCU里，包括ESP32的外设里都有脉冲宽度调制（PWM）模块，通过PWM模块我们可以进行简单的配置，就可以输出我们想要的方波波形了。好了，现在我们的程序会稍微变得复杂一点，我们不仅要调节亮度，而且我们的亮度还要随时间而改变，也就是呼吸灯的效果。从本质上来讲，我们需要随时间动态改变PWM的占空比。如果我们还用GPIO来操作，那就太复杂了，但是在ESP-IDF中已经为我们封装好了简单的PWM操作，称为LEDC组件，我们可以直接使用。
现在我们想让LED从全亮慢慢熄灭，再从熄灭逐渐变到全亮。现在我们回到程序，看看我们程序是怎么写的。好，回到程序，那现在程序会稍微变得复杂一点，我们要包含一个头文件，叫做LEDC。好了，初始化这些我暂时全部删掉，这个初始化不用删，这是初始化的接口。那我们还需要初始化一些东西，第一个要初始化的是我们的一个定时器，因为这个定时器是用在我们的LEDC上，所以说我们要初始化一下这个定时器。

那么定时器是，第一个是它的速度模式，因为我们一般设置用于呼吸灯的话，就是低速模式就行了。低速模式，第二个是定时器通道，定时器通道的话我们用LEDC0就行。然后这个是时钟，时钟的话我们用LEDC，这个是分辨率，这个是频率，不是分辨率，是PWM的频率，那么我们这边选5000吧，就用5000赫兹。这个是占空比的分辨率，占空比的分辨率，那么这里是二的幂次，比如说我们写13位，那么这里的分辨率就是二的13次方减一。嗯，看还有什么，这个一般来说不需要设置。好，我们调用这个LEDC_timer_config，好，这样子的话，就把这个用于LEDC模块的定时器初始化完毕。
那么现在还要初始化一个东西，就是LEDC通道，速度模式我们也选低速模式，通道的话我们选，因为这里有八个通道可以选，我们就选通道零吧。还有就是关联定时器，就是把我们刚才初始化的定时器关联起来，我们用的是LEDC0。还有这个GPIO引脚，因为我们刚才定义的是GPIO27。这个占空比，我们先设置成零，占空比是零的话，它就是不亮。好，这样子我们就设置完了，初始化一下，调用这个LEDC_channel_config，把这个结构体设置进去，好，我们初始化的工作就完了。
但是还有一些东西我们需要做的，因为我们用到了PWM模块，我们这边通过调用这个接口，开启我们的硬件PWM模块工作。因为我们是想要控制LED达到一个呼吸灯的效果，也就是我们的LED的PWM是渐变的。那么渐变的话，这里要开启一个LEDC渐变，那么如何开启呢？调用这个函数，第一个参数是低速模式，第二个参数是通道，我们还是通道零，那么第三个参数是占空比，目标占空比，也就是我们这个渐变的目标，是他最终要渐变到什么占空比。因为我们暂时先写零，那么它渐变过程是多久，那么我们写2000ms，这里意思就是在2000ms内，会从当前的占空比渐变成零。
好，现在我们要启动这个渐变，因为我们初始化就是零了，所以说我们这边直接填从零渐变到最大吧。那么最大二的13次方是8192，不是4096。那么这里我们要填8191。因为它是减一的关系。那么我们开启这个渐变，这个也是一样的参数通道，那么最后一个参数的意思就是，我们不用等这个渐变完成，这个函数立刻返回，不用阻塞在这里。那么我们什么时候知道它渐变完成了呢？这里就需要设定一个渐变完成的回调函数。

回调函数的话，我们先看这个回调函数怎么写，这个结构体只有一个成员，就是回调函数。我们看一下这回调函数原型吧，原型是一个返回布尔型的回调函数。那我们在最上面定义一下，这个LEDC_finish_callback。这里应该是还要包含一个头文件，通道，这个结构体，这个比较奇怪，为什么找不到呢？你看头文件里面都有，哦这边忘记填这个none，填这个分号了，好了。

那么现在我们看一下，我们这个回调函数要怎么写。回调函数里面，其实是因为这个回调函数是通知我们渐变已经完成了，我们可以从这个参数里面去提取一些有用的信息。那么我这边建议的话，还是回到这个任务里面去，我把这个任务里面删掉，我们希望这个回调函数是渐变完成之后，向我们的任务发送一个事件，这个事件通知到我们的任务，去启动新的一轮渐变。比如说我们渐变是从零到满占空比，那么通知给我们的是一个满的事件，那么我们这个任务里面就再次执行一轮渐变，就是从满到零的渐变。如果渐变完成，通知到我们最终的占空比是零，那么我们这个渐变的话就是从零开始到满。开始新一轮的渐变。所以说我们这边要定义一个事件组句柄，就叫LEDC，在这里吧，好再对应两个事件标志位，B0就叫FULL_EVENT，这个叫EMPTY_EVENT，好的。
这个函数应该是在中断里面调用的，所以说我们需要这么一个宏修饰它。那么这里它不认识，应该是还要加个头文件，哦不用。那么之前讲课有提到过，如果我们加了这个宏，就说明这个函数是放在我们的内存中执行的，而不是放在flash中执行的，那么它的效率也会比较高。那么我们这个完成回调函数里面要做如下事情，我们首先判断它的占空比结果是什么，如果占空比结果是零，那么我们就要发出这个EMPTY_EVENT事件，通知到我们的任务。如果占空比不是零，也就是满，因为我这边渐变只有两种结果，要么零，要么满，那么我们就发出一个FULL_EVENT事件通知我们的任务。
那么发事件的话，之前讲FreeRTOS的时候已经有提过，就叫……大家注意，因为它这个是在中断里面的，所以说我们要调用这个中断版本的。第二个参数是满的，我们就发这个事件。那大家不知道还记不记得，这个第三个参数的作用，第三个参数的作用就是通知到我们的程序是否有更高优先级的任务就绪。那么我们这边定义一个变量，就叫这个吧，简单一点，我们就返回这个标志就行了。

那么如果是空的话，我们就发出这个EMPTY_EVENT事件。好，我们这个回调函数就写完了。现在回到我们这个任务里面去，我们这个任务的话，就是要等待这两个事件，如果等到了是一个FULL_EVENT事件，那么我们就开启新的一轮渐变，从满到零的渐变。好，我这边设置一下等待哪两个事件，就是EMPTY_EVENT和FULL_EVENT这两个事件，等待时间我们取任意即可，就是先等个五秒钟吧，这个没所谓。那么我们需要判断这个返回值，好，如果我们收到了这个FULL_EVENT事件的话，我们就同样地要开启新的一轮渐变，也就是需要把这两个写上去，满的话就是这写零，这里是目标占空比，因为我们是满了，满的话我们从满到零，下面的话就是空了，那么我们就满两层。
那么这里要再设置一下它的回调函数，检查一下嗯，哦这里有个错误，这里的话二的13次方是8192，不是4096，那么这里我们要填8191。8191，好看一下，大致没什么问题了，大致，我这边输入加调试，看一下有没有错误。好，大家看到烧录和调试都是没有出现错误的，而开发板上现在也有一个渐变的效果，我开给大家看一下，大家看这个LED它不再是一个一闪一闪的状态，它是一个渐变的过程，就达到了我们一个呼吸灯的效果。

好了，这节课也就讲到这里了，具体的程序的话在Git仓库上，ESP32Board/LEDC这个路径上，大家可以看到具体的源码。
