这节课给大家介绍 FreeRTOS 中另外两种任务间的同步方法：事件组和直达任务通知。首先来看事件。所谓事件就是发生了某件事，而我们需要将这件事通知到对这件事感兴趣的用户上。FreeRTOS 中的事件组包含了一组事件位，每一组都可以单独设置为零或者一。为零时说明事件没有发生，为一时则说明事件发生了。这个图表示一个 24 位的事件组，但实际上只用了前三位。大家可以看到前两位是零，说明 bit id0 或者 bit 的零的事件位没有事件发生。bit 二是1，说明这个事件位被设置成有事件发生。那么这里就和信号量有点类似。大家回忆一下信号量的用法：有一个任务释放了一个信号量，然后另一个任务拿到信号量后就可以往下执行。而事件组也是类似的，一个任务设置了一个事件，如果有任务正在等待相应的事件，则此任务等待事件的函数就会结束，并返回事件编号。另外事件组可以等待多个事件中的任意一个或全部，提供了更灵活的同步方式。我个人而言更喜欢用事件组，因为很多应用情况下它都可以替代信号量。那么事件组的使用方法也很简单，以下是三个最常用的 API：

- 第一个是 `xEventGroupCreate`，创建一个事件组，返回事件组的句柄，失败的话就会返回 NULL；
- 第二个是等待事件组中某个标志位，用返回值确定哪些位已完成设置，这个函数有五个参数，第一个事件组句柄，第二个有哪些位需要等待，第三个参数是否自动清除标志位，第四个参数是否等待的标志位都成功了才返回，最后一个参数是最大阻塞时间；
- 第三个 API 是设置标志位，第四个 API 是清除标志位。

好了，接下来看下这个直达任务通知。FreeRTOS 除了之前介绍的同步特性，还有这个比较重要的东西——直达任务通知。那么什么是直达任务通知？我们先看一下直达任务通知的定义：直达任务通知，每个 RTOS 任务中都有一个任务通知数组，每条任务通知都有挂起或者非挂起的通知状态，以及一个 32 位的通知值。直达任务通知是直接发送至任务的事件，而不是通过中间对象，比如队列、事件组或信号量。向任务发送直达任务通知会将任务目标设置为挂起状态，这里的挂起不是挂起任务，而是任务通知的挂起。通知状态表示任务收到了来自某个任务的通知。而我们在用直达任务通知的时候，无需再初始化或新建其他对象句柄，直接使用任务句柄来操作通知的发送。那么这里来看下两个最基本的 API：

- 第一个是 `xTaskNotify`，用于将事件直接发送到 RTOS 任务中，并可能取消该任务的阻塞状态，这个 API 函数有三个参数，第一个参数要通知的任务句柄，第二个参数携带的通知值，第三个参数是执行的操作；
- 第二个 API 等待接收任务通知，这个函数有四个参数，第一个参数进入函数清除的通知位，第二个参数退出函数清除通知位，第三个参数收到的通知值，最后一个参数是等待时长。

现在我们直接上代码演示，看一下这个事件组和直达任务通知是怎么用的。由于时间关系，我这边已经打开了虚拟机，直接创建一个工程。好，现在直接编译，看有没有问题。编译是没有问题的，我现在刷入加调试。崩溃了，忘记创建了这个事件组句柄。那么先说一下这个程序到底会有什么效果。首先我们大概是每隔一秒钟就会标记两个事件位，也就是我们首先会打印这个 bit 的零，然后隔一秒之后又会打印这个 bit 的一，然后又返回去循环，隔一秒钟又会打印这个 bit 的零。看一下我们实验是不是这样子。大家看到和我们预想的结果是一模一样的，就是隔一秒钟会打印 bit 的零，隔一秒钟会打印 bit 的一，如此循环。

好，现在我们试一下直达任务通知的一个例子。我先把这个刚才做的实验都删掉，哦不用删掉，我就保留这两个函数，其他全部删掉。那么改一下这个定义，testA 的话就是定时发送一个任务通知值，testB 的话就是接收任务通知值并打印。好了，那么我们还要做两个事情，因为我们需要用到这个任务句柄，也就是说我们这个参数是不能为 NULL 的。testA 也就是我们定义一个 task handle，这个叫 taskAHandle。好，怎么用呢？定时发送的话，这里就 xTaskNotify，第二个是任务句柄，第二个是值，我们这样吧，定义一个值，然后每隔一秒钟增加一，然后再发送到 testB 去，看他是不是有增加。这个是 value 值，我看一下这个，我们用到的是这个操作，就是直接将目标任务的通知值无条件地设置为 value 值，也就是我们是直接把这个 value 值发送到对应目标的任务上的一个 32 位通知值上去的。好延时一毫秒，延时 1000ms。要把这个值加加，啊这边的话就 xTaskNotifyWait，那么第一个参数进入的时候要清除哪些位，我们选择不清除，第二个参数退出的时候要清除哪些位，我们选择全部清除，这 uno max 就是所有位，呃看下有哪个参数，等待的值，等待值，我们这边定一个变量，等待时间最长，等待，也就是搜不到值就一直等待在这里，house 我们把这个值打印出来。

那么我们大致分析一下这个程序，这个程序是比较简单的，任务 A 的话就是每隔一秒钟就会向任务 B 发送一个任务通知，那么这个任务通知就是携带这个 32 位的通知值，那么每隔一秒钟这个通知值就会加一，而任务 B 的话就是一直等待任务通知值，如果等到之后，那么就会把这个用户通知值打印出来，也就是理论上这个 value 打印的值提示一秒钟就会把这个 value 值加一。而大家看到我这边是没有定义任何句柄的，直接是通过这个任务句柄来操作，这也是任务通知值的一个比较好的地方，它效率比较高，而且无需中间变量。我们现在编译一下，直接烧录加调试。好，编译没问题了。不过程序崩溃了，我来看一下是什么情况。哦，这里有个问题，任务A在运行时会向任务B发送任务通知，但此时任务B的句柄还没有成功创建，所以程序崩溃了。因为任务A在创建后直接运行，而任务B的句柄还没有准备好。

我们这边最简单的方法就是加个延迟，让任务A稍微阻塞一下，让任务B有机会创建。这里随便加个200ms的延迟就行了。好，我们再编译一下。
编译通过了，现在程序运行正常。大家可以看到，每隔一秒钟，任务A会向任务B发送一个任务通知，任务B接收到通知后会打印出通知值，这个值每隔一秒钟会增加1。这就达到了我们预期的效果。

那么这节课也就讲到这里了，通过今天的讲解，大家应该对 FreeRTOS 中的事件组和直达任务通知有了更深入的理解。如果还有其他问题，欢迎随时提问。
