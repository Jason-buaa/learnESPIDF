# FreeRTOS 中的信号量与互斥锁

## 一、信号量的介绍

今天给大家介绍 FreeRTOS 中另外一种同步方式：信号量。

什么是信号量呢？大家以前在写单片机程序的时候，应该用过一些全局标志位，用于表示某项动作完成。然后另外一个函数里面就判断这个标志位，如果这个标志位为 `true`，则执行后续的操作；否则就返回。在 FreeRTOS 任务里面，信号量也是类似的作用，不过它意味着更多的东西。

为了让大家更好地理解，我这边举了个较为形象的例子来说明信号量。假设有一个雨伞池存放了一些雨伞，大家看这里有一些人来用。那么每当有一个人取走一把雨伞，池里面的雨伞就会减少，一直到所有雨伞被取走了，那么后续要用雨伞的人只能等待，直到有人归还雨伞到雨伞池里面，等待的人才能拿来用。这里的雨伞就是信号量，而使用者就是任务。只有取得信号量，任务才能继续往下执行，或者使用特定的资源。

## 二、信号量的分类

信号量分为以下几种：

- **二进制信号量**：计数值最大只能为 1，也就是说这个雨伞池里面只有一把雨伞，要么为零，要么为一。
- **计数信号量**：信号的数量可以是多个，比如刚才举的那个例子，雨伞池里面有多个雨伞。
- **互斥信号量**：用于保护临界区资源的互斥访问。

## 三、优先级继承机制

互斥信号量与二进制信号量用法极为相似，但互斥信号量实现了优先级继承机制。因此，互斥信号量常常用于临界区资源的互斥访问。

那么什么是优先级继承呢？说到这，需要给大家介绍一个问题，就是任务优先级翻转。举个例子，比如说现在有三个任务 A、B 和 C，优先级 A > B > C。现在任务 C 正在使用一个临界区资源 X，突然任务 A 也需要使用临界区资源 X，但因为任务 C 正在访问，因此需要等任务 C 使用完才能使用，A 就会阻塞在这里。这时候任务 B 就绪了，调度器就会将任务 B 切换出来运行，因为任务 B 优先级大于任务 C。那么这样就有个问题，明明任务 A 的优先级比任务 B 的优先级大，但现在任务 B 在与任务 A 没有访问资源冲突的条件下，反而能得到运行，看起来任务 A 和任务 B 的优先级就翻转了。

那如何解决这个问题呢？就需要用到优先级继承机制。回到刚才说的这个例子，任务 C 暂时继承任务 A 的优先级，自然任务 C 的优先级就和任务 A 一样，调度器就会优先执行任务 C。等任务 C 执行完了，就会执行任务 A，然后再去执行任务 B，当然解决了优先级翻转的问题。

## 四、信号量的 API 接口

接下来我们看一下一些常用的 API 接口。

首先是 `xSemaphoreCreateBinary()`，用于创建二进制信号量。如果成功的话，就会返回信号量的句柄。这个函数比较简单，它没有参数。

第二个 API 是 `xSemaphoreCreateCounting()`，用于创建计数信号量。它成功的话也会返回信号量的句柄。那么这里它有两个参数：第一个是最大信号量的数量，也就是这个雨伞池最多能容纳多少把雨伞；第二个参数是初始信号量数，也就是这个雨伞池最开始有多少把雨伞。

第三个 API 是 `xSemaphoreTake()`，尝试获取一个信号量。如果获取信号量成功，则返回 `true`。这个函数有两个参数：第一个参数是信号量句柄，也就是这两个创建信号量 API 返回的句柄；第二个参数是等待时间。那么在这个等待时间里，如果还是没有办法获取到信号量，那么这个函数就会返回 `false`，否则就会返回 `true`。

第四个 API 是 `xSemaphoreGive()`，它的参数只有一个，也就是信号量句柄。那么这个 API 是用来释放一个信号量的。

第五个 API 是删除信号量，也就是我们会释放相应的信号量资源。

## 五、互斥锁的使用

接下来看互斥锁。互斥锁比较简单，它的使用方法和信号量的 `take` 和 `give` 是一样的。唯一不一样的就是它创建的函数。它用的是 `xSemaphoreCreateMutex()`。

接下来我们看下实际代码是怎么实现的。由于时间关系，我这边在课前就已经创建好了一个工程，叫 `test_c_s_e_m`。我打开这个 VS Code 看一下。

首先，我演示一下二进制信号量是怎么用的。首先我们定义一个信号量句柄，名字就叫 `bin_sem`。再定义两个任务，这两个任务比较简单。第一个任务 A 是负责释放信号量的，每隔一秒钟就释放一个信号量。第二个任务 B 是负责等待信号量的，这里等待时间就设为无限等待。我们把打印提示写出来，任务 B 会在获取到信号量后打印提示。

那么这个简单的程序就是：任务 A 负责每隔 1000ms 释放一个信号量，任务 B 一直在等待这个信号量。如果有信号量，就会打印提示。理论上每隔一秒钟就会打印这句提示。

我们在 `main` 函数里面，首先创建任务，然后创建二进制信号量句柄。再创建两个任务，分配在内核一上运行。第二个任务的优先级改成 4。好，程序写完了，我们试一下编译看看。编译通过后，我们进行调试。可以看到，每隔 1000ms 就会打印这句提示，因为每隔 1000ms，任务 B 就从任务 A 那里获取到一个信号量。

关于计数信号量，这边我就不做演示了，因为用法比较类似，只不过它创建信号量的时候有两个参数：最大信号量的个数和初始个数。这个 `give` 可以调用多次，每 `give` 一次，计数就会加一。

## 六、互斥锁的演示

接下来主要演示互斥锁。互斥锁多用于临界区之间的访问保护。我为什么专门介绍互斥锁呢？因为在实际开发中，互斥锁是比较常用的东西。我们在实际写程序的时候，往往有很多全局变量或者公共硬件接口，需要不同任务去访问，所以我们需要一个互斥机制来保证这些临界区资源可以正确地得到访问。

接下来的程序包含了 DHT11 的驱动接口。DHT11 是一个温湿度传感器。这个文件是在课前已经写好的。这个驱动主要提供两个接口：一个是初始化，把 GPIO 引脚初始化一下；另一个是获取数据，一个是获取温度，一个是获取湿度。DHT11 是单总线通信方式，我们需要实实在在地访问 ESP3 的硬件资源。如果我们两个任务都需要用到这个接口的话，本质上我们还是需要加互斥锁的。

我们把之前的代码全部删掉，改成 DHT11 的例子。创建互斥锁不是用 `xSemaphoreCreateBinary()`，而是用 `xSemaphoreCreateMutex()`。

这个例子程序怎么写呢？本质上我们要访问一段临界区资源，所以我们需要加上互斥锁，也就是 `xSemaphoreTake()` 和 `xSemaphoreGive()`。互斥锁使用的原则是谁拿了谁释放，这样就保证了中间这一段是互斥访问的。

下面的任务 B 也是一样。我们先初始化一下，我这个课程上配套的开发板连接到 DHT11 的是 GPIO25。我们定义两个变量，一个是温度，还有一个湿度。这个接口返回的是温度值乘以 10，所以我们打印的时候需要除以 10。

为了不要那么频繁地访问 DHT11 的硬件接口，我们在使用前后都加一点延时，控制访问速度。前面加 500ms，使用完之后再延时 1 秒钟，严格控制访问频率，确保每次访问临界区资源都是稳定的。

好，这个测试用程序就写完了，我们试一下。可以看到打印结果先是任务 A 使用了，然后是任务 B，然后循环使用，而且这两个任务访问之间是没有冲突的。

接下来我们看一下，如果把互斥锁去掉会怎么样。我们直接去掉互斥锁，然后烧录调试。可以看到程序直接崩掉了。为什么崩掉了？因为这个获取温湿度传感器接口底层函数报了个错误，说这个通道当前是处于不可用的状态。不可用的原因是其中一个任务正在使用这个接口，而另一个任务又去调用它，造成了访问冲突。由此可见，互斥锁对硬件资源访问保护是很重要的，最大的危险就是程序会直接崩掉。

## 七、总结

这节课就到这里。我们介绍了 FreeRTOS 中的信号量和互斥锁，包括它们的分类、API 接口以及如何解决任务优先级翻转的问题。互斥锁在实际开发中非常重要，尤其是在访问全局变量或公共硬件接口时，能够有效避免任务之间的冲突。希望这些内容对大家有所帮助。
