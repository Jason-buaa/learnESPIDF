# FreeRTOS 操作系统学习

## 为什么学习 FreeRTOS？

从本节开始，我们一起来学习 FreeRTOS 操作系统。为什么我们需要学习这个 RTOS 操作系统呢？很明显，大家查看 IDF 里面的 example 或者自己写的代码，都是使用 FreeRTOS 操作系统。IDF 框架源码都是基于 FreeRTOS 操作系统上进行编写的。因此我们必须要学会 FreeRTOS，另外我们的程序使用 FreeRTOS 也是有很多优点的。

## 无 RTOS 与有 RTOS 的代码对比

大家可以看这里有两段伪代码：

- **无 RTOS 的代码**：
  - 每一个具体的功能模块，它们的运行都是按顺序执行的，先是 A，然后是 B、C、D，然后循环过后又是 A、B、C、D，不存在优先级一说。
  - 只要其中的一个功能模块发生等待、延时或阻塞，那么后面的那些功能模块也一同等待。
  - 这就意味着我们写程序，尽可能不要出现延时等待的语句，否则很多功能单元都会受到影响。

- **有 RTOS 的代码**：
  - 各功能模块可以说是独立并行的，运行者通过时间片的方式，每个任务都可以得到执行机会。
  - 当其中一个任务需要等待一些操作的时候，它可以把自己阻塞在这里，然后任务调度器就会寻找可执行的任务来执行，极大地提高了编程的灵活性。
  - 在 RTOS 操作系统中，任务运行时间片的基本单位是 tick，一般也可以叫系统时钟节拍。在 ESP-IDF 中，一个 tick 为一毫秒。

## FreeRTOS 操作系统的任务状态

FreeRTOS 操作系统中，任务可以存在以下几种状态：

- **运行态**：
  - 当任务实际执行时，它被称为处于运行状态，任务当前正在使用处理器。
  - 如果运行 RTOS 的处理器只有一个内核，那么在任何给定时间内，都只能有一个任务处于运行状态。

- **准备就绪态**：
  - 目的是那些能够执行，但目前是没有执行的任务，因为同等或者更高优先级的任务已经处于运行状态。

- **阻塞态**：
  - 如果任务当前正在等待事件、等待时间或者外部事件，那么该任务被认为处于阻塞状态。
  - 例如一个任务调用 `vTaskDelay`，它将被阻塞，直到延迟结束。
  - 任务也可以通过阻塞来等待队列、信号量、事件组通知或信号量等信号量事件等等。
  - 处于阻塞状态的任务通常有一个超时期，超时后任务将被超时并被解除阻塞，即使该任务所等待的事件没有发生。
  - 阻塞状态下的任务不使用任何处理时间，不能被选择进入运行状态。

- **挂起态**：
  - 挂起任务与阻塞状态的任务不一样，挂起任务不能被选择进入运行状态，但处于挂起状态的任务没有超时一说。
  - 相反，任务只有在分别通过 `vTaskSuspend` 或者 `vTaskResume` 函数调用明确命令时，才会进入或退出挂起状态。

## 在 ESP-IDF 中创建任务

在 ESP-IDF 中创建任务，使用这个函数 `xTaskCreatePinnedToCore`。这个函数是原生 FreeRTOS 中没有的，这个函数是乐鑫自己重新实现的一个函数，因为它是为了处理 ESP32 这个双核的情况。那么原生 FreeRTOS 中 `xTaskCreate` 在 ESP-IDF 中也是支持的，这个 `xTaskCreate` 函数在内部其实本质上也是调用了 `xTaskCreatePinnedToCore`，并且内核指定为 `tskNO_AFFINITY`，也就是说可以在两个内核中运行。我这里建议大家以后创建任务，就用这个乐鑫自己实现的 `xTaskCreatePinnedToCore` 函数。

这个函数原型如下，这个函数有八个参数：

- 第一个参数是任务函数指针，它原型只有一个参数，是一个 `void*` 的指针。
- 第二个参数是任务的名称，这个参数本质上是没有任何作用的，那么在打印调试的时候可能会有一些作用。
- 第三个参数指定的任务堆栈空间大小，这里的单位是字节，具体大小可根据实际情况调整，一般最小是 2048 个字节。
- 第四个参数是对应的这个任务函数指针的参数。
- 第五个参数是优先级，数字越大，优先级越高，它可取值的范围是零到这个宏定义的一个值，这里默认是 25，也就是最高优先级可以达到 24。
- 第七个参数是传回来的任务句柄，有了这个句柄，我们可以通过这个句柄对任务进行挂起、恢复、删除操作，如果不需要置为 `NULL` 即可。
- 最后一个参数是指定任务在哪个内核上运行，因为 ESP32 上是双核，这里可以选择是零或者一。

## 延时函数

- **`vTaskDelay`**：
  - 当程序调用这个函数的时候，任务会立刻进入阻塞状态，但并不意味着经过这么个周期之后，就可以立刻得到执行，具体还要看系统的调度。

- **`xTaskDelayUntil`**：
  - 这个函数可以表示精确的解除时间，时间精度相对 `vTaskDelay` 要高。
  - 第一个参数 `xPreviousWakeTime` 保存了上一次任务解除阻塞的时间。
  - 第二个参数与第一个参数结合使用，表示经过 `xPreviousWakeTime` 加上第二个参数的时间点，任务会解除阻塞。

## 示例代码

以下是一个简单的任务创建和延时示例：

```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

void TaskA(void* pvParameters) {
    while (1) {
        printf("Hello World\n");
        vTaskDelay(pdMS_TO_TICKS(500));  // 延时 500ms
    }
}

void app_main() {
    xTaskCreatePinnedToCore(
        TaskA,          // 任务函数
        "hello_world",  // 任务名称
        2048,           // 堆栈大小
        NULL,           // 任务参数
        3,              // 优先级
        NULL,           // 任务句柄
        1               // 内核选择
    );
}
```


# 示例代码讲解

## 任务函数 TaskA
这是一个简单的任务函数，每隔 500ms 打印一句 "Hello World"。
使用 `vTaskDelay(pdMS_TO_TICKS(500))` 来实现延时，`pdMS_TO_TICKS` 是一个宏，用于将毫秒转换为系统节拍数。

## 任务创建函数 xTaskCreatePinnedToCore
在 `app_main` 函数中，使用 `xTaskCreatePinnedToCore` 创建任务。
参数说明：
- `TaskA`：任务函数。
- `"hello_world"`：任务名称。
- `2048`：堆栈大小（单位为字节）。
- `NULL`：任务参数。
- `3`：任务优先级。
- `NULL`：任务句柄。
- `1`：任务运行的内核（选择应用核）。

## 编译与调试

### 创建工程
- 使用命令 `idf.py create-project` 创建一个新的工程。
- 进入工程目录，查看生成的文件结构。

### 添加 ESP-IDF 路径
- 在 VSCode 中，通过 `Ctrl+Shift+P` 调出命令面板。
- 选择 `C/C++: Edit Configurations (JSON)`，添加 ESP-IDF 的头文件路径。

### 编写代码
- 包含必要的头文件，如 `FreeRTOS.h` 和 `task.h`。
- 编写任务函数和 `app_main` 函数。

### 编译与烧录
- 使用命令 `idf.py build` 编译工程。
- 使用命令 `idf.py -p PORT flash monitor` 烧录并启动串行监视器。

## 运行结果
- 程序运行后，每隔 500ms 会打印一句 "Hello World"。
- 前面的时间戳表示打印的时间间隔，延时相对精确。

## 调试建议
- 如果程序运行不正常，检查任务优先级和堆栈大小。
- 确保任务名称和函数指针正确无误。

## 总结
本节课内容到此结束。我们学习了 FreeRTOS 的基本概念、任务状态、创建任务的方法以及延时函数的使用。通过这些知识，你可以快速入门 FreeRTOS 操作系统。如果想深入了解，可以查看 FreeRTOS 的源码。
